# 开发指南

## 理念

### 核心信念

- **渐进式进步优于大爆炸** - 能编译并通过测试的小改动
- **从现有代码中学习** - 实施前先研究和规划
- **实用主义优于教条主义** - 适应项目实际情况
- **明确意图优于巧妙代码** - 保持无聊和明显

### 简单性意味着

- 每个函数/类单一职责
- 避免过早抽象
- 不要耍小聪明 - 选择无聊的解决方案
- 如果需要解释，就是太复杂了

## 流程

### 1. 规划与分期

将复杂工作分解为3-5个阶段。在 `IMPLEMENTATION_PLAN.md` 中记录：

```markdown
## 阶段 N: [名称]
**目标**: [具体交付物]
**成功标准**: [可测试的结果]
**测试**: [具体测试用例]
**状态**: [未开始|进行中|完成]
```
- 随着进展更新状态
- 所有阶段完成后删除文件

### 2. 实施流程

1. **理解** - 研究代码库中现有模式
2. **测试** - 先写测试（红灯）
3. **实现** - 最少代码通过测试（绿灯）
4. **重构** - 在测试通过情况下清理代码
5. **提交** - 带有清晰信息链接到计划

### 3. 遇到困难时（3次尝试后）

**关键**: 每个问题最多尝试3次，然后停止。

1. **记录失败内容**：
   - 你尝试了什么
   - 具体错误信息
   - 你认为失败的原因

2. **研究替代方案**：
   - 找到2-3个类似实现
   - 记录不同的方法

3. **质疑基本假设**：
   - 这是正确的抽象层级吗？
   - 能否分解为更小的问题？
   - 是否有完全更简单的方法？

4. **尝试不同角度**：
   - 不同的库/框架特性？
   - 不同的架构模式？
   - 移除抽象而非添加？

## 技术标准

### 架构原则

- **组合优于继承** - 使用依赖注入
- **接口优于单例** - 实现测试性和灵活性
- **显式优于隐式** - 清晰的数据流和依赖关系
- **尽可能测试驱动** - 永不禁用测试，修复它们

### 代码质量

- **每次提交必须**：
  - 成功编译
  - 通过所有现有测试
  - 包含新功能的测试
  - 遵循项目格式化/检查规则

- **提交前**：
  - 运行格式化/检查工具
  - 自我审查更改
  - 确保提交信息解释"为什么"

### 错误处理

- 快速失败并提供描述性消息
- 包含调试上下文
- 在适当层级处理错误
- 永不静默吞咽异常

## 决策框架

当存在多个有效方法时，基于以下选择：

1. **可测试性** - 我能轻易测试这个吗？
2. **可读性** - 6个月后有人能理解吗？
3. **一致性** - 这是否符合项目模式？
4. **简单性** - 这是可行的最简单方案吗？
5. **可逆性** - 以后改变有多难？

## 项目集成

### 学习代码库

- 找到3个类似的功能/组件
- 识别通用模式和约定
- 尽可能使用相同的库/工具
- 遵循现有测试模式

### 工具

- 使用项目现有的构建系统
- 使用项目的测试框架
- 使用项目的格式化/检查器设置
- 没有充分理由不引入新工具

## 质量门控

### 完成定义

- [ ] 测试编写并通过
- [ ] 代码遵循项目约定
- [ ] 无检查器/格式化器警告
- [ ] 提交信息清晰
- [ ] 实现符合计划
- [ ] 没有不带问题编号的TODO

### 测试指南

- 测试行为，而非实现
- 尽可能每个测试一个断言
- 清晰的测试名称描述场景
- 使用现有测试工具/辅助函数
- 测试应该是确定性的

## 重要提醒

**永远不要**：
- 使用 `--no-verify` 绕过提交钩子
- 禁用测试而非修复它们
- 提交不能编译的代码
- 做假设 - 用现有代码验证

**始终要**：
- 渐进式提交工作代码
- 随时更新计划文档
- 从现有实现中学习
- 3次失败尝试后停止并重新评估